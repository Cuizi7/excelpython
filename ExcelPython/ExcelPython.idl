import "oaidl.idl";
import "ocidl.idl";

#define STRINGIFY2(x) #x
#define STRINGIFY(x) STRINGIFY2(x)

#if PYTHON_TARGET == 26
#define EXCELPYTHON ExcelPython26
#define EXCELPYTHON_GUID 1b5f72ca-7a70-4efc-92a6-ad2f94e3dad1
cpp_quote("#define PYTHON_TARGET 26")
cpp_quote("#define LIBID_ExcelPython LIBID_ExcelPython26")
#elif PYTHON_TARGET == 27
#define EXCELPYTHON ExcelPython27
#define EXCELPYTHON_GUID fa5a29a5-28c4-49fa-bd17-c16eeb21d1a2
cpp_quote("#define PYTHON_TARGET 27")
cpp_quote("#define LIBID_ExcelPython LIBID_ExcelPython27")
#else
#error "Invalid (or no) PYTHON_TARGET specified in compilation options."
#endif


[
	uuid(EXCELPYTHON_GUID),
	helpstring(STRINGIFY(EXCELPYTHON)),
	lcid(0x0),
	version(1.0)
]
library EXCELPYTHON
{
	[
		uuid(f7cf0020-030e-11e2-a21f-0800200c9a66)
	]
	interface IProgressCallback : IUnknown
	{
		HRESULT SetStatus([in] BSTR* status);
	};

	[
		uuid(78fc63e0-fdb5-11e1-a21f-0800200c9a66),
		dual
	]
	interface IPyObj : IDispatch
	{
		HRESULT __stdcall Str(
			[out, retval] VARIANT* Result
			);

		HRESULT __stdcall Var(
			[in, defaultvalue(-1)] LONG* xlDimensions,
			[out, retval] VARIANT* Result
			);

		[propget] //, id(DISPID_VALUE)]
		HRESULT Item(
			[in] VARIANT* Key,
			[out, retval] IPyObj** Result
		);

		[propget]
		HRESULT Attr(
			[in] BSTR Attribute,
			[out, retval] IPyObj** Result
		);

		[propget, id(DISPID_NEWENUM)]
		HRESULT __stdcall _NewEnum(
			[out, retval] IUnknown** ppUnk
		);

		[propget]
		HRESULT Count(
			[out, retval]  LONG *pVal
		);
	};

	[
		helpstring(STRINGIFY(EXCELPYTHON)),
		dllname(STRINGIFY(EXCELPYTHON) ".dll")
	]
	module ExcelPython
	{
		[entry("PyDict"), helpstring("Builds a Python dictionary object"), vararg]
		HRESULT __stdcall PyDict(
			[in] SAFEARRAY(VARIANT)* KeyValuePairs,
			[out, retval] VARIANT* Result
			);

		[entry("PyTuple"), helpstring("Builds a Python tuple object"), vararg]
		HRESULT __stdcall PyTuple(
			[in] SAFEARRAY(VARIANT)* Elements,
			[out, retval] VARIANT* Result
			);

		[entry("PyList"), helpstring("Builds a Python list object"), vararg]
		HRESULT __stdcall PyList(
			[in] SAFEARRAY(VARIANT)* Elements,
			[out, retval] VARIANT* Result
			);

		[entry("PyBuiltin"), helpstring("Calls a Python built-in method")]
		HRESULT __stdcall PyBuiltin(
			[in] BSTR Method,
			[in, optional] VARIANT* Args,
			[in, optional] VARIANT* KwArgs,
			[out, retval] VARIANT* Result
			);

		[entry("PyStr"), helpstring("Calls the Python built-in method str on Value"), vararg]
		HRESULT __stdcall PyStr(
			[in] VARIANT* Value,
			[in] SAFEARRAY(VARIANT)* FormatArgs,
			[out, retval] VARIANT* Result
			);

		[entry("PyRepr"), helpstring("Calls the Python built-in method repr on Value")]
		HRESULT __stdcall PyRepr(
			[in] VARIANT* Value,
			[out, retval] VARIANT* Result
			);

		[entry("PyLen"), helpstring("Calls the Python built-in method len on Value")]
		HRESULT __stdcall PyLen(
			[in] VARIANT* Value,
			[out, retval] int* Result
			);

		[entry("PyType"), helpstring("Calls the Python built-in method type on Value")]
		HRESULT __stdcall PyType(
			[in] VARIANT* Value,
			[out, retval] VARIANT* Result
			);

		[entry("PyCall"), helpstring("Calls an object's method. If Method is left blank the object itself is called.")]
		HRESULT __stdcall PyCall(
			[in] VARIANT* Instance,
			[in, defaultvalue(L"")] BSTR Method,
			[in, optional] VARIANT* Args,
			[in, optional] VARIANT* KwArgs,
			[in, defaultvalue(FALSE)] BOOL Console,
			[out, retval] VARIANT* Result
			);

		[entry("PyIter"), helpstring("Gets an iterator on the object (calls the __iter__ method)")]
		HRESULT __stdcall PyIter(
			[in] VARIANT* Instance,
			[out, retval] VARIANT* Result
			);

		[entry("PyNext"), helpstring("Gets the next element in the iterator (calls the next method)")]
		HRESULT __stdcall PyNext(
			[in] VARIANT* Iterator,
			[out] VARIANT* Element,
			[out, retval] VARIANT_BOOL* Result
			);

		[entry("PyGetAttr"), helpstring("Gets an object's attribute (same as PyGetAttr)")]
		HRESULT __stdcall PyGet(
			[in] VARIANT* Instance,
			[in] BSTR Attribute,
			[out, retval] VARIANT* Result
			);

		[entry("PySetAttr"), helpstring("Sets an object's attribute (same as PySetAttr)")]
		HRESULT __stdcall PySet(
			[in] VARIANT* Instance,
			[in] BSTR Attribute,
			[in] VARIANT* Value
			);

		[entry("PyGetAttr"), helpstring("Gets an object's attribute (same as PyGet)")]
		HRESULT __stdcall PyGetAttr(
			[in] VARIANT* Instance,
			[in] BSTR Attribute,
			[out, retval] VARIANT* Result
			);

		[entry("PySetAttr"), helpstring("Sets an object's attribute (same as PySet)")]
		HRESULT __stdcall PySetAttr(
			[in] VARIANT* Instance,
			[in] BSTR Attribute,
			[in] VARIANT* Value
			);

		[entry("PyDelAttr"), helpstring("Deletes an object's attribute")]
		HRESULT __stdcall PyDelAttr(
			[in] VARIANT* Instance,
			[in] BSTR Attribute
			);

		[entry("PyHasAttr"), helpstring("Tests if an object has an attribute")]
		HRESULT __stdcall PyHasAttr(
			[in] VARIANT* Instance,
			[in] BSTR Attribute,
			[out, retval] VARIANT_BOOL* Result
			);

		[entry("PyGetItem")]
		HRESULT __stdcall PyGetItem(
			[in] VARIANT* Instance,
			[in] VARIANT* Key,
			[out, retval] VARIANT* Result
			);

		[entry("PySetItem")]
		HRESULT __stdcall PySetItem(
			[in] VARIANT* Instance,
			[in] VARIANT* Key,
			[in] VARIANT* Value
			);

		[entry("PyDelItem")]
		HRESULT __stdcall PyDelItem(
			[in] VARIANT* Instance,
			[in] VARIANT* Key
			);

		[entry("PyContains"), helpstring("Tests whether Instance contains Value. Equivalent to the Python statement 'Value in Instance'")]
		HRESULT __stdcall PyContains(
			[in] VARIANT* Instance,
			[in] VARIANT* Value,
			[out, retval] VARIANT_BOOL* Result
			);

		[entry("PyEval")]
		HRESULT __stdcall PyEval(
			[in] BSTR Expression,
			[in, optional] VARIANT* Locals,
			[in, optional] VARIANT* Globals,
			[in, defaultvalue(L"")] BSTR AddPath,
			[in, defaultvalue(L"")] BSTR Path,
			[out, retval] IPyObj** Result
			);

		[entry("PyExec")]
		HRESULT __stdcall PyExec(
			[in] BSTR Statement,
			[in, optional] VARIANT* Locals,
			[in, optional] VARIANT* Globals,
			[in, defaultvalue(L"")] BSTR AddPath,
			[in, defaultvalue(L"")] BSTR Path
			);

		//[entry("PySetPath")]
		//HRESULT __stdcall PySetPath(
		//	[in] BSTR Path
		//	);

		[entry("PyModule")]
		HRESULT __stdcall PyModule(
			[in] BSTR Name,
			[in, defaultvalue(-1)] VARIANT_BOOL* Reload,
			[in, defaultvalue(L"")] BSTR AddPath,
			[in, defaultvalue(L"")] BSTR Path,
			[out, retval] VARIANT* Result
			);

		[entry("PyIsObject")]
		HRESULT __stdcall PyIsObject(
			[in] VARIANT* Value,
			[out, retval] VARIANT_BOOL* Result
			);

		[entry("PyToVariant"), helpstring("Converts a Python object to a variant (same as PyVar)")]
		HRESULT __stdcall PyToVariant(
			[in] VARIANT* Value,
			[in, defaultvalue(-1)] LONG* Dimensions,
			[out, retval] VARIANT* Result
			);

		[entry("PyToVariant"), helpstring("Converts a Python object to a variant (same as PyToVariant)")]
		HRESULT __stdcall PyVar(
			[in] VARIANT* Value,
			[in, defaultvalue(-1)] LONG* Dimensions,
			[out, retval] VARIANT* Result
			);

		[entry("PyToObject"), helpstring("Converts a variant to a Python object (same as PyObj)")]
		HRESULT __stdcall PyToObject(
			[in] VARIANT* Value,
			[in, defaultvalue(-1)] LONG* Dimensions,
			[out, retval] VARIANT* Result
			);

		[entry("PyToObject"), helpstring("Converts a variant to a Python object (same as PyToObject)")]
		HRESULT __stdcall PyObj(
			[in] VARIANT* Value,
			[in, defaultvalue(-1)] LONG* Dimensions,
			[out, retval] VARIANT* Result
			);

		//[entry("PyShowConsole")]
		//HRESULT __stdcall PyShowConsole(
		//	[in, defaultvalue(TRUE)] BOOL* Show
		//	);
	}
};